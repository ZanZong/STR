import numpy as np
from stropt.core.dfgraph import DFGraph
from stropt.core.utils.swapping import SwapControler, prun_q_opt
import stropt.core.utils.solver_common as solver_common

NOISE_EPSILON = 0.01
VAR_THRESHOLD = 0.333 - NOISE_EPSILON

def fine_grained_approx(g: DFGraph, sc: SwapControler, r: np.ndarray, s: np.ndarray, \
                            p: np.ndarray, q: np.ndarray, u: np.ndarray, mem_budget):
    """ Approximation strategy with a recursive source tracing for each s=1
    """
    T = g.size 
    p_ = np.zeros((T, T), dtype=solver_common.SOLVER_DTYPE)
    q_ = np.floor(q)
    r_ = np.floor(r)
    s_ = np.floor(s)
    u_ = np.copy(u)
    q_ = prun_q_opt(sc, q_, s_)
    need_filled_s = []
    temp_ram_cache = np.zeros(T, dtype=solver_common.SOLVER_DTYPE) # a column ram cache

    def bandwidth_free(start_stage, finish_stage):
        """Check if there is no swapping operations between start_stage and finish_stage
        """
        x, y = np.nonzero(q_)
        for t, i in zip(x, y):
            fs = sc.swap_finish_stage(t, i)
            assert fs is not None, "Find illegal swap in q"
            if (t >= start_stage and t <= finish_stage) or \
                (fs >= start_stage and fs <= finish_stage):
                return False
        return True

    def cacheable(t, i):
        """Is there any spare space to cache tensor i in stage t
        """
        if u[t, i] + g.cost_ram[i] <= mem_budget:
            temp_ram_cache[t] = g.cost_ram[i]
            return True
        else:
            return False

    def source_tracing(t: int, i: int):
        """S[t,i] exist before, find how it was generated recursively, compute or swap?
        namely follows S[t,i] <= S[t-1,i] + R[t-1,i] + Q[ss(t-1,i),i].
        """
        if t <= i:
            return False
        exist_before = s_[t - 1, i] == 1
        if exist_before:
            return source_tracing(t - 1, i)
        # S[t,i] is generated by computing at t-1 stage
        compute_justnow = r_[t - 1, i] == 1
        if compute_justnow:
            return True
        # S[t,i] is generated by finishing swap-in at t-1 stage
        swap_justnow = False
        start_stage = sc.swap_start_stage(t - 1, i)
        if start_stage is not None:
            if q_[start_stage, i] == 1:
                swap_justnow = True
            elif q[start_stage, i] > 0 and bandwidth_free(start_stage, t - 1):
                # find swap opportunity in unapproximated q
                q_[start_stage, i] = 1
                swap_justnow = True
                print(f"Correct {start_stage},{i} from {q[start_stage, i]} " + \
                                    f"to {q_[start_stage, i]} for s[{t},{i}]=1")
        if swap_justnow:
            return True
        # Try to swapping earlier, assume s_[t-1] is existing
        # if free_slot(i):
        if cacheable(t - 1, i):
            need_filled_s.append((t - 1, i))
            u_[:, i] += temp_ram_cache
            return source_tracing(t - 1, i)
        else:
            return False

    adj = [[] for _ in range(T)]
    for (eu, ev) in g.edge_list:
        adj[ev].append(eu)
    
    # Recursive source tracing
    for ev in range(T):
        t = ev
        for eu in adj[ev]:
            print(f"Edge {eu}->{ev}")
            # assert r_[t, ev] <= r_[t, eu] + s_[t, eu], \
            #     f"The solution breaks constraints: r[{t},{ev}]<=r[{t},{eu}]+s[{t},{eu}]"
            if r_[t, ev] > r_[t, eu] + s_[t, eu]:
                r_[t, eu] = 1
                for recompute_source in adj[eu]:
                    if s_[t, recompute_source] == 0:
                        r_[t, recompute_source] = 1

            if s_[t, eu] == 1:
                if source_tracing(t, eu):
                    for tup in need_filled_s:
                        s_[tup[0], tup[1]] = 1
                    u[:, eu] = u_[:, eu]
                else:
                    print(f"Error: cannot find the source of s_[{t},{eu}]=1")
                    # using R to fix the rule
                    r_[t, eu] = 1
                need_filled_s.clear()
                np.where(temp_ram_cache > 0, temp_ram_cache, 0)

    # TODO fix p
    return r_, s_, p_, q_


def pick_row_max(mat, out_mat):
    row_axis_max = []
    # row axis max value
    for t, max_idx in enumerate(np.argmax(mat, axis=1)):
        if mat[t, max_idx] >= VAR_THRESHOLD:
            row_axis_max.append((t, max_idx))
    for (t, i) in row_axis_max:
            out_mat[t, i] = 1
